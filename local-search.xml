<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2024.6.10-6.16周报</title>
    <link href="/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/report/weekly_report240617/"/>
    <url>/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/report/weekly_report240617/</url>
    
    <content type="html"><![CDATA[<h1 id="开头的一些废话"><a href="#开头的一些废话" class="headerlink" title="开头的一些废话"></a>开头的一些废话</h1><p>2024年已快过半，感觉这小半年来看了很多东西但又像没看一样，各类笔记记录也都零零散散的。刚好在之前规范了自己记录学习内容和各类idea的方式，通常也会在晚上睡前梳理一遍今天内容的大纲，进而想着像写工作日报周报一样，也对每周的内容进行一个汇总（变相给自己没什么人看的主页增添内容，给自己上压力催更）。</p><p>关于内容，一般而言会分为：</p><ul><li>平时的算法练习（Leetcode main，日替和周赛双周赛练习）及思路分析总结；</li><li>最近感兴趣的领域的内容学习记录（近期大概是电路基础、数学以及&#9632;&#9632;&#9632;&#9632;，还有反复看了半天的”abandon”的图形学）；</li><li>外语学习（大概是保持语感，最近在跟看<a href="https://book.douban.com/subject/27116778/">英语词根与单词的说文解字</a>，一方面是为了学习词根尝试扩展词汇量，另一方面是为了&#9632;&#9632;&#9632;&#9632;，并且为了&#9632;&#9632;&#9632;&#9632;，后续大概还准备看词根、词源相关的语言学资料）；</li><li>阅读的记录（不是正式的笔记，大概是一两句简单的感想，也会去参考别人的书评，其中一个目的也是为了&#9632;&#9632;&#9632;&#9632;）；</li><li>技术文档阅读记录（和前面的非技术类书籍资料分开记录）；</li><li>其他内容的摘录（来自各类SNS的感兴趣的信息记录，像<a href="https://www.reddit.com/r/Lunamos/comments/1dfsds3/%E6%8F%BD%E6%9C%88%E5%91%A8%E5%88%8A11_%E6%97%A7%E4%B8%96%E4%B9%8B%E6%9C%88%E7%9A%84%E5%B0%8F%E5%A4%9C%E6%9B%B2/">Lunamos的红迪频道的揽月周刊</a>一般的记录，说是SNS其实还包括一些RSS订阅源的内容，也许会有一些观影的记录，还是为了&#9632;&#9632;&#9632;&#9632;）；</li><li>考虑中的新的学习计划（目前考虑继续Rust和ArkTS的学习）；</li></ul><p>最后应该还有一点对本周内容的总结与反思。</p><p>每周的周报正篇大标题也许会有不一样的东西。</p><p><strong>（&#9632;&#9632;&#9632;&#9632;暂不公开）</strong></p><h1 id="“正义"><a href="#“正义" class="headerlink" title="“正义&lt;命运”的一周做了什么"></a>“正义&lt;命运”的一周做了什么</h1><p>这一周看了源刚放出没多久的<a href="https://movie.douban.com/subject/34822168/">Seed Freedom剧场版</a>，名场面过多笑得睡不着觉，取其中之一作为本周的标题，为无聊的主页增添一点喜剧色彩（电波系的）。</p><h2 id="1-算法练习记录"><a href="#1-算法练习记录" class="headerlink" title="1 算法练习记录"></a>1 算法练习记录</h2><h3 id="0610-0616日替算法题"><a href="#0610-0616日替算法题" class="headerlink" title="0610-0616日替算法题"></a>0610-0616日替算法题</h3><ul><li><a href="https://leetcode.cn/problems/boats-to-save-people/description/?envType=daily-question&envId=2024-06-10">lc881.救生艇</a><ul><li>简单的贪心，先排序，将尽量轻的和尽量重的安排在一条船上；</li><li>使用双指针分别指向体重最轻和最重的人；</li></ul></li><li><a href="https://leetcode.cn/problems/battleships-in-a-board/description/?envType=daily-question&envId=2024-06-11">lc419.甲板上的战舰</a><ul><li>战舰不相邻-&gt;直接枚举战舰的一个端点即可，因为每个战舰是一个连通分量，统计连通分量的数量即可；</li></ul></li><li><a href="https://leetcode.cn/problems/account-balance-after-rounded-purchase/description/?envType=daily-question&envId=2024-06-12">lc2806.取整购买后的账户余额</a><ul><li>简单的四舍五入；</li></ul></li><li><a href="https://leetcode.cn/problems/maximum-elegance-of-a-k-length-subsequence/description/?envType=daily-question&envId=2024-06-13">lc2813.子序列最大优雅度</a></li><li><a href="https://leetcode.cn/problems/visit-array-positions-to-maximize-score/description/?envType=daily-question&envId=2024-06-14">lc2786.访问数组中的位置使分数最大</a><ul><li>个人分析时能想到了dp的思路，但由于题目要求看错，导致最后的结果错误，但思路没有问题，<code>dp[i]</code>的状态定义为移动到i的最大得分，但状态转移需要考虑之前的所有可能性，时间复杂度高；</li><li>题解的优化思路：只使用两个位置保存数据，一个记录由奇数转移过来的分数，另一个记录由偶数转移过来的最大分数，只需一次遍历即可；</li></ul></li><li><a href="https://leetcode.cn/problems/maximum-beauty-of-an-array-after-applying-operation/description/?envType=daily-question&envId=2024-06-15">lc2779.数组的最大美丽值</a><ul><li>排序+滑动窗口，可以排序是因为根据子序列的定义，元素的顺序对数组的美丽值没有影响；<ul><li>特殊题设要求下的子序列的顺序无关性（有点拗口，但自己懂）；</li></ul></li></ul></li><li><a href="https://leetcode.cn/problems/longest-uncommon-subsequence-i/description/?envType=daily-question&envId=2024-06-16">lc521.最长特殊序列Ⅰ</a></li></ul><p>总的看下来，每次看到序列题都感觉CPU烧了，和序列题的相性不好，要继续加练。</p><h3 id="周赛与双周赛"><a href="#周赛与双周赛" class="headerlink" title="周赛与双周赛"></a>周赛与双周赛</h3><p>关于周赛和双周赛一般是学习和总结上一周的竞赛内容。</p><ul><li>第401场周赛内容地址：<a href="https://leetcode.cn/contest/weekly-contest-401/">https://leetcode.cn/contest/weekly-contest-401/</a></li><li>第132场双周赛内容地址：<a href="https://leetcode.cn/contest/biweekly-contest-132/">https://leetcode.cn/contest/biweekly-contest-132/</a></li></ul><p>（周赛内容工事中）</p><h2 id="2-电路基础内容"><a href="#2-电路基础内容" class="headerlink" title="2 电路基础内容"></a>2 电路基础内容</h2><p>电路部分主要是想要捡起以前本科专业的内容，或者说“捡起”这一词并不准确，是在本科选修课的基础上深入学习这一专业本该掌握、但学院并未开设相应课程的内容。</p><p>第一步的打算是补完常见元器件的基础和简单接触不同元器件常用的电路应用。</p><p>本周主要学习了：</p><ul><li>电阻电路的分析、戴维宁等效电路、常用的电阻电路之分压器，另外经常使用的是动态电源或动态信号激励，还补充学习了小信号分析方法引入的小信号电阻，以应对后期的动态电路分析；</li><li>电容、电感的时域分析，包括以下内容：<ul><li>电容、电感的基础知识；</li><li>一阶电路时域分析（RL电路和RC电路）——零输入响应、零状态响应、完全响应（紧急复习了常微分方程内容）；</li><li>二阶电路时域分析（RLC电路：串联、并联）；</li></ul></li><li>频域分析的一些知识预备：<ul><li>复数的基本内容：表示（代数、三角形式和指数形式）；</li><li>信号与正弦信号；</li><li>相量法及常用定理的推广；</li></ul></li></ul><p>元器件的基本性质和常见的使用方式还是很重要的，但在学习到后期的时域和频域分析时，感觉到更重要的是分析和建模方法，至于数学计算上在实际使用时再考虑，并且由于现在并没有实际的场景可以进行设计（因为学习不完全的原因），这一部分内容的学习反馈不强，后期考虑继续后面的元器件的学习，之后再倒回来继续关注频域方面的内容。</p><p>另外，学习过程中主要参考了<a href="https://book.douban.com/subject/1896907/">《电路》</a>和<a href="https://book.douban.com/subject/3614183/">《The art of electronics》</a>两本书，前者是国内的电路分析教材，主要关注理论上的内容，后者也会有理论上的内容，但更多介绍了实际的应用场景（指常用的电子电路）。</p><h2 id="3-外语学习"><a href="#3-外语学习" class="headerlink" title="3 外语学习"></a>3 外语学习</h2><p>本周学习的英语词根是<a href="https://book.douban.com/subject/27116778/">英语词根与单词的说文解字</a>一书的第二部分（120个最常用的英语词根）中<code>A</code>开头的部分，并非本书中所有<code>A</code>开头的词根。</p><p>另外周报的该部分只记录近一周看过的词根及其简单溯源（深入的溯源在之后慢慢考据，也是受了<a href="https://book.douban.com/subject/36463571/">《巴别塔》</a>的影响，另一方面也是为了&#9632;&#9632;&#9632;&#9632;练习设定），并不涉及具体的词汇积累。</p><ol><li>ag，act [ L ] &#x3D; to do or drive 做；驱使<ul><li>拉丁动词<strong>agere</strong>的词干部分，相当于to do或to drive；</li><li>act来自<strong>agere</strong>的分词形式<strong>actum</strong>的词干部分，基本含义相同；</li></ul></li><li>am(at) [ L ] &#x3D; to love 爱<ul><li>am是拉丁动词<strong>amare</strong>的现在词干，而amat是动词的分词词干；</li><li>amic来自名词<strong>amicus</strong>；</li><li>在练习中出现的变体：em是am的变体；</li></ul></li><li>anim [ L ] &#x3D; life 声明<ul><li>anim源于<strong>anima</strong>，包含思想、精神、灵魂和生存等与生命现象有关的概念；</li><li>anima一词非常熟悉，第一次知道该词是FFX的同名召唤兽；</li></ul></li><li>ann，enn [ L ] &#x3D; year 年<ul><li>ann来自拉丁名词<strong>annus</strong>，意思是年，构词时常跟连接字母’-i-‘或’-u-‘；</li><li>enn是ann添加前缀时产生的音变异体；<ul><li>是否普遍存在a-&gt;e的音变异体？</li></ul></li><li>biannual和biennial的辨析；</li></ul></li><li>anthrop(o) [ GK ] &#x3D; man 人类<ul><li>词源是希腊名词<strong>anthropos</strong>，意为man或human being；</li></ul></li><li>arch [ GK ] &#x3D; rule 统治<ul><li>来自希腊名词<strong>arkhos</strong>；</li><li>派生词中arch常作ruler（统治者）或government（政体）用；</li><li>还可当前缀使用，意为chief（主要的）；</li></ul></li><li>aud(it) [ L ] &#x3D; to hear 听<ul><li>aud和audit分别来源于拉丁动词<strong>audire</strong>的现在词干和分词词干；</li></ul></li><li>aug，auct，auth [ L ] &#x3D; to increase 增加<ul><li>来源于拉丁动词<strong>aguere</strong>，过去分词<strong>auctus</strong>和变体<strong>auth</strong>，基本意思都是to increase或to cause to grow；</li></ul></li></ol><p>在进行词根学习的同时，也进行着词缀的收集，尝试着整理构词规律，留下了一些问题但尚未解决，留作下一周的课题。</p><h2 id="4-阅读记录"><a href="#4-阅读记录" class="headerlink" title="4 阅读记录"></a>4 阅读记录</h2><p>本周并未进行其他的书籍阅读，暂定将<a href="https://book.douban.com/subject/36463571/">《巴别塔》</a>的内容填补到本周的阅读内容中来。</p><p>(阅读记录工事中)</p><h2 id="5-技术文档阅读记录"><a href="#5-技术文档阅读记录" class="headerlink" title="5 技术文档阅读记录"></a>5 技术文档阅读记录</h2><p>本周无，我有罪.jpg。</p><h2 id="6-其他"><a href="#6-其他" class="headerlink" title="6 其他"></a>6 其他</h2><p>本周主要从红迪的订阅频道中看到了很多新鲜的东西：</p><ol><li>RetroTink4K：对我暂时好像还没啥用，虽然有想过去搞一台CRT回来；</li><li>《Techno Feudalism：What Killed Capitalism》：频道中推荐的一本书，讲技术封建主义，纳入读书清单.jpg；</li><li>《The Art of Doing Science and Engineering》：还是推书，感觉像是抽象层面的内容，不一定看得进去；</li><li><a href="https://www.cartographersguild.com/">幻想世界地图为主题的论坛</a>：里面有很多幻想风格RPG的世界大地图，设定考据党狂喜；</li><li><a href="https://monseter6502.com/">6502CPU的板级复刻项目</a>：使用了MOS管，之前尝试使用Rust写过NES Emulator，NES就使用的是6502改，单纯是对硬件实现感兴趣（至于跟着教程写的NES Emulator已经被自己腰斩或者说搁置，之后再继续）；<ul><li>另外，Emulator的实现主要参考了<a href="https://bugzmanov.github.io/nes_ebook/">Writing NES Emulator in Rust</a>和NES wiki以及6502的参考手册，拾起了一点以前写汇编的回忆；</li></ul></li><li>Game Maker’s Toolkit新出的“The 100 Games That Taught Me Game Design”：还没看，感觉可以继续补完樱井政博的ytb channel——<a href="https://www.youtube.com/@sora_sakurai_jp">桜井政博のゲーム作るには</a>，然后结合着看，看看不同制作者之间的设计思路；</li><li>A parttern Language：紧接在上一条下面的回复中提及的内容，一开始是用在建筑学上，描述现代乌托邦社区建设指南，也用在游戏上，后面还接着推荐了一篇文章《形式抽象设计工具》（名字不确定，作者Doug Church）。</li></ol><h1 id="总结与反思"><a href="#总结与反思" class="headerlink" title="总结与反思"></a>总结与反思</h1><p>写到这里想起来，本职干的后端开发的内容并没有记录在此处，也许会有部分内容出没在技术文档的阅读中。</p><p>本周主要还是以下三个问题，和没开始记录的时候一样：</p><ol><li>学的内容过杂：突出一个既要又要还要，虽说技多不压身但好像每一项都不深，也就没办法称为“技”；</li><li>内容记录了但入脑不深，晚上有梳理的过程了但还要加强记忆.jpg；</li><li>效率还是有待提升，纠正自己多线程的习惯。</li></ol><p>最后附上几幅图，是像素图绘画练习，来源是《像素艺术背景画法完全解析》，画完看着挺像那么回事的。（作为版底）</p><div style="text-align:center;">  <img src="/img/weekly_report240617/apple.png" alt="apple" style="margin: 5px;">  <img src="/img/weekly_report240617/pencil.png" alt="pencil" style="margin: 5px;">  <img src="/img/weekly_report240617/house.png" alt="house" style="margin: 5px;">  <img src="/img/weekly_report240617/umbrella.png" alt="umbrella" style="margin: 5px;">  <img src="/img/weekly_report240617/dice.png" alt="dice" style="margin: 5px;"></div><p>（完）</p>]]></content>
    
    
    <categories>
      
      <category>学习记录</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂谈</tag>
      
      <tag>周报</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust中的生命周期杂谈</title>
    <link href="/Rust/rust/lifetime/"/>
    <url>/Rust/rust/lifetime/</url>
    
    <content type="html"><![CDATA[<h1 id="引入：“悬垂”带来的内存管理问题"><a href="#引入：“悬垂”带来的内存管理问题" class="headerlink" title="引入：“悬垂”带来的内存管理问题"></a>引入：“悬垂”带来的内存管理问题</h1><p>“悬垂”是一种在内存管理中常见的问题，在支持指针的语言中会出现的是悬垂指针，而在Rust中出现的则是悬垂引用问题。</p><p>悬垂引用（Dangling References）可以进行通过悬垂指针（Dangling Pointer）进行类比。悬垂指针是在释放内存时保留了指向它的指针时产生的，此时指向的内存可能已经被分配给其它持有者，最终可能导致错误的结果。悬垂引用则是Rust中引用带来的问题，是引用指向了一个不再有效的内存位置，它又与Rust的生命周期模型和所有权模型相关。</p><p>在Rust中，悬垂引用是不被允许存在的。在试图创建一个一个悬垂引用时，Rust会通过编译时错误来避免这个问题。一个尝试创建悬垂引用的代码如下<a href="https://rustwiki.org/zh-CN/book/ch04-02-references-and-borrowing.html#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8dangling-references">[1]</a>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">reference_to_nothing</span> = <span class="hljs-title function_ invoke__">dangle</span>();<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">dangle</span>() <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">String</span> &#123;    <span class="hljs-comment">// 返回字符串的引用</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>);   <span class="hljs-comment">// s是新字符串</span><br><br>    &amp;s <span class="hljs-comment">// 返回字符串s的引用</span><br>&#125; <span class="hljs-comment">// s离开作用域被丢弃，内存释放</span><br>  <span class="hljs-comment">// 此时返回的引用指向一个无效的String</span><br></code></pre></td></tr></table></figure><p>实际上这里应当返回一个<code>String</code>，此时函数体内的<code>s</code>被直接返回，该字符串的所有权被移动给外面调用该函数并赋值的变量。</p><p>如果运行上面的代码，会得到以下的错误信息<a href="https://rustwiki.org/zh-CN/book/ch04-02-references-and-borrowing.html#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8dangling-references">[1]</a>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">cargo run</span><br>   Compiling ownership v0.1.0 (file:///projects/ownership)<br>error[E0106]: missing lifetime specifier<br><span class="hljs-meta prompt_"> --&gt; </span><span class="language-bash">src/main.rs:5:16</span><br>  |<br>5 | fn dangle() -&gt; &amp;String &#123;<br>  |                ^ expected named lifetime parameter<br>  |<br>  = help: this function&#x27;s return type contains a borrowed value, but there is no value for it to be borrowed from<br>help: consider using the `&#x27;static` lifetime<br>  |<br>5 | fn dangle() -&gt; &amp;&#x27;static String &#123;<br>  |                ^^^^^^^^<br><br>For more information about this error, try `rustc --explain E0106`.<br>error: could not compile `ownership` due to previous error<br></code></pre></td></tr></table></figure><p>该错误信息提醒我们应当对返回的引用使用<code>&#39;static</code>的生命周期注释，引出了生命周期的话题，而关于该注释将在后文进行介绍，此处暂且不谈。</p><p>由此可以看出，Rust在编译阶段就可以避免这种“悬垂”的问题。这是因为在编译器里面有一个借用检查器，它会在编译时就比较各借用的作用域，确保所有借用都是有效的。</p><h1 id="保证安全的工具：借用检查器"><a href="#保证安全的工具：借用检查器" class="headerlink" title="保证安全的工具：借用检查器"></a>保证安全的工具：借用检查器</h1><p>借用这一概念基于Rust独特的所有权机制，它可以使Rust在不需要垃圾回收器的情况下保证内存的安全性。借用检查器基于两条基本原则来工作：</p><ul><li><strong>借用规则</strong>：任一时刻，一个资源要么被可变借用独占，要么由多个不可变借用共享；</li><li><strong>生命周期规则</strong>：引用必须总是有效的，确保引用不能比它引用的数据获得更久；</li></ul><p>其中，借用规则与读写锁的原理类似，还可以通过这一套规则来防止数据竞争，保证<strong>并发任务</strong>的安全性。</p><h1 id="生命周期：保证引用的有效性"><a href="#生命周期：保证引用的有效性" class="headerlink" title="生命周期：保证引用的有效性"></a>生命周期：保证引用的有效性</h1><p>在Rust中，每一个引用都有它的生命周期，即引用保持有效的作用域。在大多数时候是可以自动推断的，但也有引用以不同方式关联的情况，此时就需要使用泛型生命周期参数来注明关系，以保证运行时使用的引用是有效的。也就是说，生命周期最大的一个目的就是——<strong>避免产生悬垂引用</strong>。</p><h2 id="显式标注与隐式的自动推断（省略标注）"><a href="#显式标注与隐式的自动推断（省略标注）" class="headerlink" title="显式标注与隐式的自动推断（省略标注）"></a>显式标注与隐式的自动推断（省略标注）</h2><p>一个比较重要的问题就是：何时可以省略生命周期标注让编译器自行推断，而何时又必须使用显式标注？</p><p>关于这个问题，将在接下来的几个场景中进行讨论，但在此之前可以给出的是Rust中给出的<strong>生命周期省略规则</strong>（lifetime elision rules）<a href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5lifetime-elision">[1]</a>。</p><h3 id="生命周期省略规则"><a href="#生命周期省略规则" class="headerlink" title="生命周期省略规则"></a>生命周期省略规则</h3><ol><li>每一个是引用的参数都有它自己的生命周期参数；<ul><li>该条规则适用于输入生命周期，即函数或方法的参数的生命周期；</li><li>举例：<code>fn foo&lt;&#39;a, &#39;b&gt;(x: &amp;&#39;a i32, y: &amp;&#39;b i32)</code>，<code>x</code>和<code>y</code>是两个对<code>i32</code>类型的引用，按照规则它们拥有自己的生命周期，此处用<code>&#39;a</code>和<code>&#39;b</code>进行标注；</li></ul></li><li>如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数；<ul><li>该条规则适用于输出生命周期，即返回值的生命周期；</li><li>举例：<code>fn foo&lt;&#39;a&gt;(x: &amp;&#39;a i32) -&gt; &amp;&#39;a i32</code>，此处只有一个输入引用参数，只对应一个生命周期，则该生命周期也被赋予给返回值中的引用；</li></ul></li><li>如果方法有多个输入生命周期参数并且其中一个参数是<code>&amp;self</code>或<code>&amp;mut self</code>，说明是个对象的方法，则所有输出生命周期参数被赋予<code>self</code>的生命周期；<ul><li>该条规则适用于输出生命周期，且用于方法；</li></ul></li></ol><p>借用<a href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9C%81%E7%95%A5lifetime-elision">[1]</a>中的多参数情况下对三条规则的分析示例来解读这三条规则：</p><ul><li>给出一个函数签名，此时签名中的引用没有关联任何生命周期：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>(x: &amp;<span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;&#125;<br></code></pre></td></tr></table></figure></li><li>应用第一条规则——每个引用参数有其自己的生命周期，这里称之为<code>&#39;a</code>和<code>&#39;b</code>，改写函数签名：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li>应用第二条规则，由于函数存在多个生命周期，不适用于该种情况；</li><li>应用第三条规则，同样不适用，因为没有self；</li></ul><p>由此出现了一个问题，该函数并不能通过编译器的通过。因为在应用了三条规则之后，仍然无法确定返回值类型的生命周期。如何确定返回值的生命周期呢？</p><h3 id="函数中的泛型生命周期"><a href="#函数中的泛型生命周期" class="headerlink" title="函数中的泛型生命周期"></a>函数中的泛型生命周期</h3><p>以上一节中讨论的<code>longest</code>函数为例，它的作用是返回两个字符串中更长的那个字符串，其实现代码如下<a href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html#%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">[1]</a>，其中生命周期标注已按上节的分析补全：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>, <span class="hljs-symbol">&#x27;b</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;b</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该函数的内部实现包含一个选择分支结构，执行时只希望比较它们的长度而不转移所有权，所以传入了两个字符串的引用，而结果只有在运行时才能知晓，所以Rust无法得知返回的引用指向<code>x</code>还是<code>y</code>；借用检查器也不能确定<code>x</code>和<code>y</code>的生命周期如何与返回值生命周期关联。</p><p>实际上，Rust对带生命周期的签名函数有相应的限制：</p><ul><li>任何引用都必须拥有标注好的生命周期；</li><li>任何被返回的引用都必须有和某个输入量相同的生命周期或是静态类型（<code>static</code>）；</li></ul><p>也就是说可以对<code>longest</code>函数进行以下的修改：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>&#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这表明对于生命周期<code>&#39;a</code>，函数会获取两个与<code>&#39;a</code>存在一样长的字符串slice，函数也会返回一个与<code>&#39;a</code>一样长的字符串slice。其实际含义是<code>longest</code>返回的引用的生命周期与传入该函数的生命周期的较小者一致，而函数不关心<code>x</code>和<code>y</code>具体存在多久，只知道有某个可以被<code>&#39;a</code>替代的作用域会满足该签名。被<code>&#39;a</code>替代的具体生命周期是<code>x</code>与<code>y</code>的作用域相重叠的部分，或者说是它们之中生命周期<strong>较小</strong>的那一个。</p><p>可以将上面的内容总结为下面几点：</p><ul><li>无法确定生命周期的情况下，需要使用显式标注的方式来标注引用的生命周期。</li><li>函数的返回值的输出生命周期要么与输入生命周期有关联（相同），要么应当是静态类型。</li><li>若返回值总返回其中一个参数，其他参数也可以不标注生命周期，因为它们之间没有关联。</li></ul><h3 id="方法中的泛型生命周期"><a href="#方法中的泛型生命周期" class="headerlink" title="方法中的泛型生命周期"></a>方法中的泛型生命周期</h3><p>方法的生命周期标注与函数类似，但是由生命周期省略规则的第三条，对于方法而言，是属于某一对象的，其参数里面包括<code>self</code>，也就是说<code>self</code>的生命周期会赋给所有的输出生命周期参数。因此，标注可以省略。</p><h3 id="结构体中的泛型生命周期"><a href="#结构体中的泛型生命周期" class="headerlink" title="结构体中的泛型生命周期"></a>结构体中的泛型生命周期</h3><p>当一个结构体的变量中存在引用时，就需要对结构体中的每一个引用添加生命周期标注，如下的示例代码<a href="https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime/struct.html">[2]</a>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">NamedBorrowed</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>,<br>    y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，生命周期标注<code>&#39;a</code>的意思是该结构体的实例不能比这两个字段的引用存在的更久。</p><h2 id="特殊的生命周期：-static"><a href="#特殊的生命周期：-static" class="headerlink" title="特殊的生命周期：&#39;static"></a>特殊的生命周期：<code>&#39;static</code></h2><p><code>&#39;static</code>代表了静态生命周期，它可以存活于整个程序期间。特别地，所有的字符串字面量都拥有<code>&#39;static</code>生命周期。使变量拥有<code>&#39;static</code>生命周期有两种方式，它们把数据保存在可执行文件的只读内存取：</p><ul><li>使用<code>static</code>声明常量；</li><li>产生一个拥有<code>&amp;&#39;static str</code>类型的<code>string</code>字面量；</li></ul><p>另外，静态生命周期可以被强制转换成一个更短的生命周期<a href="https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime/static_lifetime.html">[2]</a>：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> NUM: <span class="hljs-type">i32</span> = <span class="hljs-number">18</span>;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">coerce_static</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(_: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span> &#123;<br>    &amp;NUM<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个函数返回对常量<code>NUM</code>的引用，但是其返回值的生命周期被设定为<code>&#39;a</code>，它一定比<code>&#39;static</code>更短，这种强制转换是合法的。</p><h2 id="用于约束"><a href="#用于约束" class="headerlink" title="用于约束"></a>用于约束</h2><p>由于生命周期也是泛型，所以也可以使用约束。</p><ul><li><code>T: &#39;a</code>：在<code>T</code>中的<strong>所有</strong>引用都必须比生命周期<code>&#39;a</code>长；</li><li><code>T: Trait + &#39;a</code>：<code>T</code>类型必须实现<code>Trait</code> trait，并且在<code>T</code>中的所有引用都必须比<code>&#39;a</code>活得更长。</li></ul><p>可以看出，<code>:</code>符号的含义在此处为位于前面的对象比位于符号后面的对象要活得更长。由此，也可以对生命周期进行约束：</p><ul><li><code>&#39;a: &#39;b</code>：<code>&#39;a</code>比<code>&#39;b</code>存活的时间更长，只要<code>&amp;&#39;b ()</code>有效，引用<code>&amp;&#39;a ()</code>就有效。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>[1] Rust程序语言设计. <a href="https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html">https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html</a><br>[2] Rust By Example. <a href="https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime.html">https://rustwiki.org/zh-CN/rust-by-example/scope/lifetime.html</a><br>[3] Rust参考手册. <a href="https://rustwiki.org/zh-CN/reference/">https://rustwiki.org/zh-CN/reference/</a></p>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>编程语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始的图形学与游戏开发（零）</title>
    <link href="/%E5%9B%BE%E5%BD%A2%E5%AD%A6/graphics/graphics_note_0/"/>
    <url>/%E5%9B%BE%E5%BD%A2%E5%AD%A6/graphics/graphics_note_0/</url>
    
    <content type="html"><![CDATA[<p>严格来说，并不能算是真正的从零开始进行图形学的学习。在之前其实已经有看过相关课程对图形学的知识体系有了大致的概念，这里只是希望重新梳理知识点并记录学习的过程。</p><p>关于自己，其实在以前并不是研究图形学相关方向的，只是兴趣使然，也算是拓宽自己的知识面，选择了这样一个方向进行私下的研究，也并非希望研究出什么具体的成果来，但至少谈起这一方面希望自己有一个完整的知识体系架构。</p><h1 id="计划与阅读计划"><a href="#计划与阅读计划" class="headerlink" title="计划与阅读计划"></a>计划与阅读计划</h1><p><strong>更新中</strong></p><ol><li>以GAMES101为线索，从数学基础开始，沿着数学在不同方面的应用来进行学习与记录；</li><li>大致的顺序为：数学基础-图形变换-几何体表示-光线追踪-着色-阴影-物理相关内容；该顺序参考了“3D游戏编程中的数学”一书的目录整理而来，具体记录时可能视情况有所变更；</li><li>关于游戏开放方面的内容，在图形学基础之后进行目标设立；</li><li>具体实施时，先阅读相关参考资料后进行记录，为此设立暂定的阅读计划：</li></ol><ul><li>Mathematics for 3D Game Programming and Computer Graphics</li><li>*Computational Geometry</li><li>Fundamentals of Computer Graphics</li><li>Real-Time Rendering</li></ul><h1 id="笔记导览"><a href="#笔记导览" class="headerlink" title="笔记导览"></a>笔记导览</h1><p><strong>更新中</strong></p><p><a href="http://localhost:4000/2023/12/29/graphics/graphics_note_1/">一</a></p><h1 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h1><ol><li>2023-12-28：叙述整体学习框架，设立相关计划于目标；</li></ol>]]></content>
    
    
    <categories>
      
      <category>图形学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图形学</tag>
      
      <tag>游戏开发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于我和不定期可能更新的杂谈</title>
    <link href="/uncategorized/about-me/"/>
    <url>/uncategorized/about-me/</url>
    
    <content type="html"><![CDATA[<h1 id="关于个人主页"><a href="#关于个人主页" class="headerlink" title="关于个人主页"></a>关于个人主页</h1><h2 id="关于个人"><a href="#关于个人" class="headerlink" title="关于个人"></a>关于个人</h2><p>一个喜欢传统纸质记录的人拖延至今终于搭建了个人主页。</p><p>本质是一个求知欲旺盛啥都想学但啥都不精的人，兴趣爱好是情报收集和ACGN，喜欢RPG和文字ADV游戏，守备范围也许算宽，梦想的职业是——拾穗人。</p><div class="note note-success">            <p><strong>有关拾穗人：</strong><a href="https://ff14.huijiwiki.com/wiki/%E8%90%A8%E9%9B%B7%E5%AE%89#%E6%8B%BE%E7%A9%97%E4%BA%BA%E6%80%BB%E4%BC%9A">拾穗人与拾穗人总会</a><br>是梦中情职，大概是不存在的。</p>          </div><p>主页上大概会记录一些笔记归档、杂谈和一些计划中和未计划的事，也可能会记录一些豆知识。</p><p>最近在学习图形学和游戏引擎。</p><h2 id="关于Pseudo-Zanarkand"><a href="#关于Pseudo-Zanarkand" class="headerlink" title="关于Pseudo Zanarkand"></a>关于Pseudo Zanarkand</h2><p>第一次见到Pseudo一词是在学习专业基础时，Pseudo code即伪代码，取“伪”一义；Zanarkand是游戏Final Fantasy X中对于主角一行人极为重要的地方，其意义对我也产生的重要的影响，是一个悲但浪漫的地方。</p><p>现实中大抵是不会存在这样的地方的，希望能和祈之子一样在梦里构筑自己的Zanarkand。</p><p>总之是自己做梦的地方。</p><h2 id="写博客的原因"><a href="#写博客的原因" class="headerlink" title="写博客的原因"></a>写博客的原因</h2><p>“正经人谁写日记啊！”</p><p>以及也许是一些文字练习。</p><p>一个比较重要的原因后续更新。</p><p>各种内容还在学习中。</p><hr><p><strong>2023.10.12更新</strong></p><p>一个重要的原因是受到了一个喜欢的up主（Lunamos）激励。Lunamos也是一名游戏玩家，有一个专题节目叫“游戏通鉴”，内容主要是怀旧主题，讲述一些老游戏的游戏体验和故事的主要内容，并且还有多种讲述方式，其中以“电子书”形式的讲述最引入入胜，以第一人称叙述将听众&#x2F;观众带入故事当中，在通勤或者吃饭的时候也可以当作背景音。</p><p>另外根据Luna自己在节目中的叙述，我个人推测是在日本从事图形学开发的相关工作，这也一定程度上让我找回了当初专业选择的初心，也促使我在前一段时间一直沉浸在图形学的相关知识中（虽然没入脑多少）。</p><p>在我看来一个文案极佳，善于演说的人突然有一天悄没声的在自己的小号上开始了电台节目，个人在电台里叙说是为了锻炼自己的口才。于是我开始了自己早已打算的博客搭建，一来是向他学习，二来是慢慢找回写作的手感，同时也是锻炼自己的逻辑思维，改善我长时间以来下笔写文文字支离破碎的问题。</p><h1 id="更新中与已完结"><a href="#更新中与已完结" class="headerlink" title="更新中与已完结"></a>更新中与已完结</h1><ul><li>从零开始的图形学与游戏开发（绝赞滞后中）</li><li>硬件记忆找回作战（更新中，从电路基础开始）</li></ul><h1 id="TodoList"><a href="#TodoList" class="headerlink" title="TodoList"></a>TodoList</h1><ul><li>记录日课</li><li>某些企划的文字记录</li><li>最近在阅读游戏设计相关书籍，也许会慢慢开始写一些游戏日志（主要谈游玩体验）</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
